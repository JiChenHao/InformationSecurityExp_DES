//这个用来测试从文件中读入信息
#include "ThisHead.h"
#include "ReadData.h"
#include "Translate2To16.h"
#include "SubKeyGenerator.h"
#include "DealPlaintext.h"
#include "SBox.h"
using namespace std;


int main() {
	string fileName = "Plaintext.txt";
	string fileNameNum2 = "PlaintextNum2.txt";
	ReadData* reader = new ReadData();

	//尝试读入字符
	//map<int,string> keyMap = reader->getDataofChar(fileName);

	//尝试读入二进制
	//map<int,int>keyMap = reader->getDataofnum2(fileName);

	//尝试将读入的二进制转化为16进制输出
	/*Translate2To16* trans = new Translate2To16();
	int size = keyMap.size();
	for (int i = 0; i < size; i+=4) {
		string str16 = trans->translate2To16(keyMap[i], keyMap[i + 1], keyMap[i + 2], keyMap[i + 3]);
		cout << "16进制是" << str16 << endl;
	}*/

	//将读入的字母转换成二进制
	/*map<int, string>::iterator mit = keyMap.begin();
	for (; mit != keyMap.end(); mit++)
	{
		reader->translateStringToNum2(mit->second);
	}*/
	//尝试将二进制写入文件
	//map<int, int> num2Map = reader->getCharToNum2(fileName, fileNameNum2);
	//map<int, int> SourceKey = reader->getCharToNum2("SourceKey.txt", "SourceKeyNum2.txt");
	//测试读取PC1
	//map<int, int>pc1 = reader->getDataofnumInt("PC1.txt");
	//map<int, int> sourceKey = reader->getCharToNum2("SourceKey.txt", "SourceKeyNum2.txt");
	//SubKeyGenerator* skG = new SubKeyGenerator(sourceKey);
	//skG->changePosition1();
	//string fileNameOfPCRule = "ruleOfPositionChange.txt";
	//skG->changePositionOfSubKey(fileNameOfPCRule);
	//尝试初始化明文处理类
	DealPlaintext* dealPT = new DealPlaintext();
	//尝试输出分组后的明文
	//cout << "=====分组后的明文输出开始=====" << endl;
	//map<int, map<int, int>>::iterator it = dealPT->plainTexts.begin();
	//for (; it != dealPT->plainTexts.end(); it++)
	//{
	//	map<int, int>::iterator it1 = it->second.begin();
	//	//cout << "***分组编号" <<it->first<<"***" << endl;
	//	/*for (; it1 != it->second.end(); it1++)
	//	{
	//		cout << "KEY:" << it1->first << " VAL:" << it1->second << endl;
	//	}*/
	//}
	//cout << "-----分组后的明文输出结束-----" << endl;
	//map<int,map<int, int>> LR0 = dealPT->IPChange(dealPT->plainTexts[1]);
	//map<int, int> resultOfEExtension = dealPT->EExtension(LR0[2]);
	////输出R0
	//map<int, int>::iterator R0IT = LR0[2].begin();
	//cout << "=====输出R0=====" << endl;
	//for (; R0IT != LR0[2].end(); R0IT++)
	//{
	//	cout << "KEY:" << R0IT->first << " VAL:" << R0IT->second << endl;
	//}
	//cout << "-----R0输出结束-----" << endl;
	////输出E扩展的结果看对不对
	//map<int, int>::iterator EEIT = resultOfEExtension.begin();
	//cout << "=====输出E扩展结果=====" << endl;
	//for (; EEIT != resultOfEExtension.end(); EEIT++)
	//{
	//	cout << "KEY:" << EEIT->first << " VAL:" << EEIT->second << endl;
	//}
	//cout << "-----E扩展结果输出结束-----" << endl;
	//测试SBox的构造函数
	//SBoxs* sB = new SBoxs();
	//获得C

	
	return 0;
}