//这个用来测试从文件中读入信息
#include "ThisHead.h"
#include "ReadData.h"
#include "Translate2To16.h"
#include "SubKeyGenerator.h"
#include "DealPlaintext.h"
#include "SBox.h"
#include "Show16.h"
using namespace std;


int main() {
	string fileName = "Plaintext.txt";
	string fileNameNum2 = "PlaintextNum2.txt";
	ReadData* reader = new ReadData();

	//尝试读入字符
	//map<int,string> keyMap = reader->getDataofChar(fileName);

	//尝试读入二进制
	//map<int,int>keyMap = reader->getDataofnum2(fileName);

	//尝试将读入的二进制转化为16进制输出
	/*Translate2To16* trans = new Translate2To16();
	int size = keyMap.size();
	for (int i = 0; i < size; i+=4) {
		string str16 = trans->translate2To16(keyMap[i], keyMap[i + 1], keyMap[i + 2], keyMap[i + 3]);
		cout << "16进制是" << str16 << endl;
	}*/

	//将读入的字母转换成二进制
	/*map<int, string>::iterator mit = keyMap.begin();
	for (; mit != keyMap.end(); mit++)
	{
		reader->translateStringToNum2(mit->second);
	}*/
	//尝试将二进制写入文件
	//map<int, int> num2Map = reader->getCharToNum2(fileName, fileNameNum2);
	//map<int, int> SourceKey = reader->getCharToNum2("SourceKey.txt", "SourceKeyNum2.txt");
	//测试读取PC1
	//map<int, int>pc1 = reader->getDataofnumInt("PC1.txt");
	//map<int, int> sourceKey = reader->getCharToNum2("SourceKey.txt", "SourceKeyNum2.txt");
	//SubKeyGenerator* skG = new SubKeyGenerator(sourceKey);
	//skG->changePosition1();
	//string fileNameOfPCRule = "ruleOfPositionChange.txt";
	//skG->changePositionOfSubKey(fileNameOfPCRule);
	//尝试初始化明文处理类
	//DealPlaintext* dealPT = new DealPlaintext();
	//尝试输出分组后的明文
	//cout << "=====分组后的明文输出开始=====" << endl;
	//map<int, map<int, int>>::iterator it = dealPT->plainTexts.begin();
	//for (; it != dealPT->plainTexts.end(); it++)
	//{
	//	map<int, int>::iterator it1 = it->second.begin();
	//	//cout << "***分组编号" <<it->first<<"***" << endl;
	//	/*for (; it1 != it->second.end(); it1++)
	//	{
	//		cout << "KEY:" << it1->first << " VAL:" << it1->second << endl;
	//	}*/
	//}
	//cout << "-----分组后的明文输出结束-----" << endl;
	//map<int,map<int, int>> LR0 = dealPT->IPChange(dealPT->plainTexts[1]);
	//map<int, int> resultOfEExtension = dealPT->EExtension(LR0[2]);
	////输出R0
	//map<int, int>::iterator R0IT = LR0[2].begin();
	//cout << "=====输出R0=====" << endl;
	//for (; R0IT != LR0[2].end(); R0IT++)
	//{
	//	cout << "KEY:" << R0IT->first << " VAL:" << R0IT->second << endl;
	//}
	//cout << "-----R0输出结束-----" << endl;
	////输出E扩展的结果看对不对
	//map<int, int>::iterator EEIT = resultOfEExtension.begin();
	//cout << "=====输出E扩展结果=====" << endl;
	//for (; EEIT != resultOfEExtension.end(); EEIT++)
	//{
	//	cout << "KEY:" << EEIT->first << " VAL:" << EEIT->second << endl;
	//}
	//cout << "-----E扩展结果输出结束-----" << endl;
	//测试SBox的构造函数
	//SBoxs* sB = new SBoxs();
	//获得C（先让R0经过E扩展，然后与密钥进行异或运算得到B）
	/*map<int, int>pt = dealPT->plainTexts[1];
	map<int, map<int, int>>LR0 = dealPT->IPChange(pt);
	map<int, int> EA = dealPT->EExtension(LR0[2]);
	SubKeyGenerator* subKeys = new SubKeyGenerator();
	map<int, int> subK1 = subKeys->subKeys[1];
	map<int, int>B = dealPT->yiHuoYunSuan(EA, subK1);
	map<int, int>C = dealPT->doSBoxChange(B);
	map<int, int>::iterator Cit = C.begin();
	cout << "输出C" << endl;
	for (; Cit != C.end(); Cit++)
	{
		cout << "KEY:" << Cit->first << " VAL:" << Cit->second << endl;
	}*/
	//测试一轮密文生成
	/*DealPlaintext* dPT = new DealPlaintext();
	map<int, int> plainText = dPT->plainTexts[1];
	cout << "=====输出明文=====" << endl;
	map<int, int>::iterator CPit = plainText.begin();
	for (; CPit != plainText.end(); CPit++)
	{
		cout << "KEY:" << CPit->first << " VAL:" << CPit->second << endl;
	}
	cout << "=====明文输出结束=====" << endl;
	map<int,int>cipherText = dPT->DES16(plainText);*/

	//尝试输出分好组的明文
	/*DealPlaintext* dPT = new DealPlaintext();
	map<int, map<int, int>>::iterator PTSit = dPT->plainTexts.begin();
	for (; PTSit != dPT->plainTexts.end(); PTSit++)
	{
		cout << "=====明文组数：" << PTSit->first << endl;
		map<int, int>::iterator PTit = PTSit->second.begin();
		for (; PTit != PTSit->second.end(); PTit++)
		{
			cout << "KEY: " << PTit->first << " VAL:" << PTit->second << endl;
		}
	}*/
	//使用数字访问分好组的明文
	DealPlaintext* dPT = new DealPlaintext();
	/*for (int i = 1; i <= 4; i++)
	{
		for (int j = 1; j <= 64; j++)
		{
			cout << "KEY: " << j << " VAL:" << dPT->plainTexts[i][j] << endl;
		}
	}*/
	//使用16进制表示明文
	//Show16* show16 = new Show16();
	//使用分好组的明文生成一组密文
	//dPT->DESall();
	//map<int, int> pts = reader->getCharToNum2("Plaintext.txt", "PlaintextNum2.txt");
	//map<int, string>pts16 = show16->changeMap2ToMap16(pts);
	//输出16进制
	/*cout << "=====输出16进制明文=====" << endl;
	map<int, string>::iterator pts16It = pts16.begin();
	for (; pts16It != pts16.end(); pts16It++)
	{
		cout << "KEY:" << pts16It->first << " VAL：" << pts16It->second << endl;
	}*/
	return 0;
}